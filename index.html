<!DOCTYPE html><html lang="en" prefix="og:http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="language" content="en"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="author" content="Alex Ostrovski"><meta name="keywords" content="ed25519, cryptography"><meta name="description" content="Ed25519 is a public-key digital signature cryptosystem proposed in 2011 by the team lead by Daniel J. Bernstein. It is a particular variant of EdDSA (Digital Signature Algorithm on twisted Edwards curves)."><meta name="og:title" content="Introduction into Ed25519"><meta name="og:description" content="Ed25519 is a public-key digital signature cryptosystem proposed in 2011 by the team lead by Daniel J. Bernstein. It is a particular variant of EdDSA (Digital Signature Algorithm on twisted Edwards curves)."><meta name="og:type" content="article"><title>Introduction into Ed25519 | Ed25519 Quirks</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous"><link rel="stylesheet" href="./base.css"></head><body><header class="body-header"><div class="container"><h1 class="display-3"><a class="d-block" href=".">Ed25519 Quirks</a></h1><nav class="navbar navbar-expand-lg navbar-light px-0 pb-0"><button class="navbar-toggler mb-1" type="button" data-toggle="collapse" data-target="#main-nav-content" aria-controls="main-nav-content" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="main-nav-content"><ul class="navbar-nav mr-auto"><li class="nav-item"><a class="nav-link" href="./basics/">Basics</a></li><li class="nav-item"><a class="nav-link" href="./malleability/">Malleability</a></li><li class="nav-item"><a class="nav-link" href="./wildcards/">Wildcards</a></li></ul><ul class="navbar-nav"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Settings</a><div class="dropdown-menu dropdown-menu-right"><h6 class="dropdown-header">Encoding</h6><form class="mx-3 my-1" id="encoding-form"><div class="custom-control custom-radio custom-control-inline"><input class="custom-control-input" id="encoding-hex" type="radio" name="encoding" value="hex"><label class="custom-control-label" for="encoding-hex">Hex</label></div><div class="custom-control custom-radio custom-control-inline"><input class="custom-control-input" id="encoding-base64" type="radio" name="encoding" value="base64"><label class="custom-control-label" for="encoding-base64">Base64</label></div></form></div></li></ul></div></nav></div></header><div class="container pt-4"><p class="lead"><a href="https://ed25519.cr.yp.to/ed25519-20110926.pdf">Ed25519</a>
is a public-key digital signature cryptosystem proposed in 2011 by the team lead by Daniel J. Bernstein.
It is a particular variant of EdDSA (<strong>D</strong>igital <strong>S</strong>ignature <strong>A</strong>lgorithm
on twisted <strong>Ed</strong>wards curves).
</p><p>Ed25519 is quite fast due to a particular choice of the curve and avoids common pitfalls of previous
elliptic curve-based cryptosystems, such as
<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Security">ECDSA</a>,
in particular boosting resistance to side-channel attacks. However, due to some peculiarities
in Ed25519 construction, it’s not always easy to use it correctly for applications besides digital signatures,
which are becoming increasingly popular with the advent of cryptocurrencies and popularization of
applied cryptography in general.
</p><h3>Basic Definitions</h3><p>Ed25519 uses an eponymous elliptic curve. For the sake of this discussion, it’s not necessary to have
a deep understanding how elliptic curves are organized.
It suffices to say that the curve consists of <em>points</em>, which form
a <a href="https://en.wikipedia.org/wiki/Abelian_group#Finite_abelian_groups">finite abelian group</a>.
As per group definition, it is possible to operate on two group points resulting in a group point,
and to multiply group by <em>scalars</em> (integers modulo a certain number),
again resulting in a point.
</p><ul><li>We will refer the group operation as addition and denote it as such: <code>A + B</code>.</li></li><li>Multiplication of a point <code>A</code> by the scalar <code>x</code> will be denoted as <code>[x]A</code>.</li></ul><p>The group has a distinguished <em>identity point</em> <code>O</code>, which plays a similar role
to zero in integer modulo groups: adding <code>O</code> to any point <code>A</code> results in <code>A</code>.
</p><p>The Ed25519 elliptic curve has <code>8ℓ</code> points, where the prime</p><p class="px-2 py-1 bg-light equation text-monospace">ℓ = 2<sup>252</sup> + 27742317777372353535851937790883648493</p><p>So, unlike some other elliptic curves (say, secp256k1 used in Bitcoin and Ethereum cryptocurrencies),
the elliptic curve is not a prime-order group itself. As per
<a href="https://en.wikipedia.org/wiki/Abelian_group#Classification">basis theorem for finite abelian groups</a>,
we can extract a prime-order subgroup by selecting a <em>basepoint</em> <code>B</code>
with order <code>ℓ</code> and using it as the group generator:</p><p class="px-2 py-1 bg-light equation text-monospace">G = { O, B, [2]B, [3]B, … [ℓ - 1]B };</p><p>(<code>[ℓ]B = O</code> by definition). For this reason, we will assume in further discussion that scalars
are integers modulo <code>ℓ</code>, rather than <code>8ℓ</code>.
</p><h3>Schnorr Signature Scheme</h3><p>As some other signature schemes based on elliptic curves, Ed25519 is essentially the non-interactive version
of a proof of knowledge of a <a href="https://en.wikipedia.org/wiki/Discrete_logarithm">discrete logarithm</a>.
In the original interactive form of the protocol, one proves that he knows
a scalar <code>a</code> corresponding to a certain group element <code>A = [a]B</code>
without revealing any information about <code>a</code>. The protocol goes as follows:
</p><ol><li><strong>Prover:</strong> Choose a random scalar <code>r</code>.</li><li><strong>Prover → Verifier:</strong> Send <code>R := [r]B</code>.</li><li><strong>Verifier → Prover:</strong> Choose and send a random scalar <code>h</code>.</li><li><strong>Prover → Verifier:</strong> Compute and send <code>s := r + h*a</code>.</li><li><strong>Verifier:</strong> Verify that <code>[s]B == R + [h]A</code>.</li></ol><p>Turns out that this protocol is complete (if the prover knows <code>a</code>, the verifier will be convinced
by the proof), sound (the prover cannot produce the necessary output if he doesn’t know <code>a</code>)
and zero-knowledge (the verifier doesn’t learn anything about <code>a</code> he didn’t know before the protocol
was initiated).</p><p>To convert this protocol into a digital signature scheme, we apply
<a href="https://link.springer.com/chapter/10.1007%2F3-540-47721-7_12">the Fiat – Shamir heuristic</a>:
the verifier is replaced with a cryptographic hash function <code>Hash</code>, which, when the verifier’s output
is requested, hashes all data sent so far by the prover together with the message <code>M</code> being signed.
In other words, <code>h := Hash(R ‖ M)</code>, where <code>‖</code> denotes concatenation of bytes.
If the cryptographic hash function models
a <a href="https://en.wikipedia.org/wiki/Random_oracle">random oracle</a>,
the resulting scheme (known as <a href="https://patents.google.com/patent/US4995082">Schnorr signature scheme</a>)
is secure.
</p><p>The Schnorr scheme for elliptic curves looks as follows:</p><ul><li><strong>Public parameters:</strong> A prime-order group on an elliptic curve with the basepoint <code>B</code>,
in which the discrete logarithm problem (finding scalar <code>a</code> given point <code>[a]B</code>)
is believed to be hard.</li><li><strong>Key generation:</strong> Select random scalar <code>a</code> as the secret (aka signing) key.
Use <code>A = [a]B</code> as the public (verifying) key.</li><li><strong>Signing:</strong> Select random scalar <code>r</code>. Compute <code>R := [r]B</code>,
<code>h := Hash(R ‖ M)</code>, and finally <code>s := r + h*a</code>. Output <code>(R, s)</code>.</li><li><strong>Verification:</strong> Given the public key <code>A</code> and signature <code>(R, s)</code>,
verify <code>[s]B == R + [Hash(R ‖ M)]A</code>.</li></ul><div class="row mt-4"><div class="col-md-5 ml-auto text-md-right"><a href="./basics/">Creating and verifying signatures<span class="text-muted">→</span></a></div></div><footer class="page-footer small text-muted"><span class="copyright">© 2019 Alex Ostrovski. Licensed under
<a rel="license" href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a>.</span><div class="float-none float-sm-right"><a href="./about/">About</a>&nbsp;•
<a href="https://github.com/slowli/ed25519-quirks">GitHub</a></div></footer></div><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script><script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script><script>$(function() {
  var encoding = localStorage.getItem('encoding') || '';
  if (['hex', 'base64'].indexOf(encoding) < 0) {
    encoding = 'base64';
    localStorage.setItem('encoding', encoding);
  }

  $('input[name=encoding]').each(function(el) {
    var $this = $(this);
    $this.prop('checked', $this.val() === encoding);
  }).change(function() {
    localStorage.setItem('encoding', $('input[name=encoding]:checked').val());
  });
});
</script></body></html>